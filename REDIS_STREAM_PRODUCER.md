**Purpose**
- Добавить минималистичный (KISS) продьюсер Redis Streams для передачи всех данных объявления и item specifics в сервис‑потребитель.

**Что Добавлено**
- Файл `ebay_my/redis_stream_producer.py` с ленивой инициализацией `redis.asyncio.Redis` из `.env` и функцией:
  - `async def push_product(item_id: str, inner_payload: dict) -> str` — публикует 1 запись в Redis Stream.
- Интеграция в `ebay_my/main.py` (функция `product()`): после успешного `PackageCommit.commit()` формируется payload и вызывается `push_product(...)`.
- Зависимость `python-dotenv` (автозагрузка переменных из `.env`).
- Образец настроек: `ebay_my/.env.example`.

**Поток И Сообщение**
- Ключ стрима: берётся из окружения `REDIS_STREAM_KEY` (по умолчанию `ebay_validation_stream`).
- Гранулярность: 1 запись = 1 товар (одно объявление eBay).
- Поля записи в Redis Stream: ровно одно поле `data` (строка JSON, UTF‑8).
- Топ‑уровень JSON: `{ "<item_id>": { ...объект объявления... } }`.
- Внутри объекта:
  - Базовые поля: `query`, `condition`, `Brand`, `title`, `location`, `price`, `price_without_delivery`, `seller` (если доступны);
  - Все пары item specifics (все `dt`/`dd`) с исходными ключами и значениями 1:1 (без нормализации, без переименования);
  - Никаких обязательных проверок на стороне продьюсера не выполняется.
- Дублирующее поле `id` (копия `item_id`) пока не добавляется — по запросу можно включить.

**Поведение И Ошибки**
- Отправка вызывается после успешной записи в БД (коммит), то есть публикуются только новые товары, которые уже отфильтрованы SQL‑логикой.
- В случае ошибки XADD пишется warning‑лог, основной процесс парсинга не прерывается.
- Никаких ретраев, пайплайна, MAXLEN‑тримминга и дедупликации на уровне Redis — принцип KISS. При необходимости легко включается точечно.

**Переменные Окружения (.env)**
- `REDIS_HOST`, `REDIS_PORT`, `REDIS_PASSWORD` — параметры подключения к Redis.
- `REDIS_STREAM_KEY` — ключ стрима для публикации.
- Значения можно задать через `.env` (подхватывается автоматически) или через переменные окружения контейнера.

**Использование В Коде**
- Паблишер вызывается из `product()` после `PackageCommit.commit()`:
  - Формируется словарь `inner_payload` с базовыми полями и всеми item specifics;
  - Выполняется `await push_product(item_id, inner_payload)`.
- В БД значения ключей/значений item specifics усечены по ограничениям схемы; в Redis Stream отправляется полная версия 1:1 (без усечения).

**Пример Сообщения**
```
XADD ebay_validation_stream * data "{\"277067090582\":{\"query\":\"420066027\",\"condition\":\"New\",\"Brand\":\"Sea-Doo\",\"title\":\"Sea-Doo OEM Genuine Part 420066027\",\"location\":\"Located in: Seattle, Washington, United States\",\"Country/Region of Manufacture\":\"Japan\",\"price\":\"99.99\",\"price_without_delivery\":\"89.99\",\"SKU\":\"420066027\",\"Manufacturer Part Number\":\"420066027\"}}"
```

**Ограничения И Опции**
- По умолчанию нет `id` внутри объекта; при необходимости можно добавить дублирование `id` для совместимости.
- Поле `data` можно переименовать по требованию потребителя.
- Можно добавить лёгкую дедупликацию на стороне продьюсера (`SETNX dedupe:<item_id>`), ретраи XADD и MAXLEN‑тримминг — сейчас отключены ради простоты.

